#_page131_

"""
Алгори́тм Де́йкстры (англ. Dijkstra’s algorithm) — алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса.

Каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a. Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки. Работа алгоритма завершается, когда все вершины посещены.

Инициализация. Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности. Это отражает то, что расстояния от a до других вершин пока неизвестны. Все вершины графа помечаются как непосещённые.

Шаг алгоритма. Если все вершины посещены, алгоритм завершается. В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку. Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом. Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.
"""

graph = {}
graph[“you”] = [“alice”, “bob”, “claire”]
graph[“start”] = {}
graph[“start”][“a”] = 6
graph[“start”][“b”] = 2

"""
>>> print graph[“start”].keys()
[“a”, “b”]
>>> print graph[“start”][“a”]
2
>>> print graph[“start”][“b”]
6
"""

graph[“a”] = {}
graph[“a”][“fin”] = 1
graph[“b”] = {}
graph[“b”][“a”] = 3
graph[“b”][“fin”] = 5
graph[“fin”] = {}                 			#Финальный узел не имеет соседей



infinity = float(“inf”)
costs = {}
costs[“a”] = 6
costs[“b”] = 2
costs[“fin”] = infinity

parents = {}
parents[“a”] = “start”
parents[“b”] = “start”
parents[“fin”] = None

processed = []



node = find_lowest_cost_node(costs)          # Найдем самый дешевый необработанный узел
while node is not None:                      # Если все узлы обработаны, этот цикл закончен.
	cost = costs[node]
	neighbors = graph[node]
	for n in neighbors.keys():               # Пройдем через всех соседей этого узла. 
		new_cost = cost + neighbors[n]
		if costs[n] > new_cost:              # Если дешевле попасть в этого соседа через этот узел…
			costs[n] = new_cost              # … обновим цену для этого узла.
			parents[n] = node                # Этот узел становится новым родителем для этого соседа.
	processed.append(node)                   # Помечаем этот узел как обработанный   
	node = find_lowest_cost_node(costs)      # Находим новый узел для исследования
	


def find_lowest_cost_node(costs):
	lowest_cost = float(“inf”)
	lowest_cost_node = None
	for node in costs:               					  # Пройдем через все узлы.
		cost = costs[node]
 		if cost < lowest_cost and node not in processed:  # Если это наименьшая цена и не была еще обработана…
 			lowest_cost = cost                            # … обновим ценовой минимум.
 			lowest_cost_node = node
	return lowest_cost_node


# Код корректный и хорошо отражает смысл алгоритма

